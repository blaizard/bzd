#pragma once

#include <cassert>

#include "tools/bdl/lang/cc/adapter/types.h"

{for use in useList}
#include "{use.path}"
{end}

{if isNamespace}
namespace {namespace | namespaceToStr} {
{end}

{for data in usingList}
using {data.name} = {data.type | typeToStr};
{end}

{for data in enumList}
{data.comment | normalComment}
enum class {data.name}
{
	{for i, value in data.valueList}{if i}, {end}{value}{end}
};
{end}

{for data in nestedList}
{data.comment | normalComment}
class {data.name}
{
public: // Types
	{for enum in data.nested.enumList}
	{enum.comment | normalComment}
	enum class {enum.name}
	{
		{for i, value in enum.valueList}{if i}, {end}{value}{end}
	};
	{end}

public: // Methods.

	{for method in data.nested.methodList}
	{method.comment | normalComment}
	virtual {method.type | typeToStr} {method.name}({for i, var in method.args}{if var.const}const {end}{var.type | typeToStr} {var.name}{if var.isValue} = {var.value}{end}{if i},{end}{end}) = 0;
	{end}

public: // Variable accessors.

	{for var in data.nested.variableList}

	// Getter for {var.name}_.
	constexpr const {var.type | typeToStr}& get{var.name | camelCase}() const noexcept
	{
		return {var.name}_;
	}

	{if not var.const}
	// Setter for {var.name}_.
	constexpr void set{var.name | camelCase}(const {var.type | typeToStr}& value)
	{
		{for contract in var.contracts}
		{if contract.type == "min"}
		// Minimum contract
		assert(value >= {contract.value});
		{end}
		{if contract.type == "max"}
		// Maximum contract
		assert(value <= {contract.value});
		{end}
		{end}

		{var.name}_ = value;
	}
	{end}
	{end}

protected: // Protected variable accessors.

	{for var in data.nested.variableList}

	{if var.const}
	// Setter for {var.name}_.
	constexpr void set{var.name | camelCase}(const {var.type | typeToStr}& value)
	{
		{for contract in var.contracts}
		{if contract.type == "min"}
		// Minimum contract
		assert(value >= {contract.value});
		{end}
		{if contract.type == "max"}
		// Maximum contract
		assert(value <= {contract.value});
		{end}
		{end}

		{var.name}_ = value;
	}
	{end}
	{end}

private: // Variables.

	{for var in data.nested.variableList}
	{var.comment | normalComment}
	{var.type | typeToStr} {var.name}_{{{if var.isValue}{var.value}{end}}};
	{end}
}};
{end}

{if isNamespace}
}
{end}
