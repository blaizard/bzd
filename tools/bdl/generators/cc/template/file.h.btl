{#- Reusable macros -#}

{#- Enum -#}
{%- macro makeEnum(element) %}
	{{ element.comment | normalComment }}
	enum class {{ element.name }} : bzd::UInt8Type
	{
		{%- for i, value in element.values -%}
		{%- if i -%},{%- end -%}
		{{ value.comment | normalComment }}
		{{ value.name }}
		{%- end %}
	};
{% end -%}

{#- Contract assertion -#}
{%- macro makeContractAssertions(sequence) -%}
	{%- for contract in sequence -%}
		{% if contract.type == "min" -%}
			// Minimum contract
			assert(value >= {{ contract.value }});
		{% elif contract.type == "max" -%}
			// Maximum contract
			assert(value <= {{ contract.value }});
		{% end -%}
	{%- end -%} 
{%- end -%}

{#- Variables -#}
{%- macro makeVariable(element, prepend) -%}
{{- element.comment | normalComment }}
{{ element.type | typeToStr }} {{ element.name }}{{ prepend }}{ {%- if element.isValue %}{{ element.value }}{% end -%} };
{%- end -%}

{#- Nested structure -#}
{%- macro makeStruct(element) -%}
	{{ element.comment | normalComment -}}
	struct {{ element.name }}{%- if element.hasInheritance %} : {{ element.inheritanceList | inheritanceToStr -}}{%- end %}
	{
		{{ makeTrivialTypes(element.nested.symbols) }}
		{%- for element in element.nested.variableList -%}
		{{ makeVariable(element, "") }}
		{% end -%}
	};
{%- end -%}

{#- Build types -#}
{%- macro makeTrivialTypes(sequence) -%}
	{%- for data in sequence -%}
		{#- using -#}
		{%- if data.category == "using" -%}
			{{ data.comment | normalComment }}
			using {{ data.name }} = {{ data.type | typeToStr }};

		{#- enum -#}
		{%- elif data.category == "enum" -%}
			{{ makeEnum(data) }}

		{#- nested -#}
		{%- elif data.category == "nested" -%}
			{% if data.type == "struct" %} 
				{{ makeStruct(data) }}
			{%- end -%}

		{%- end -%}
	{%- end -%}
{%- end -%}

{#- Start of the actual template -#}

#pragma once

#include <cassert>

#include "tools/bdl/generators/cc/adapter/types.h"

{% for use in useList -%}
#include "{{ use.path | bdlPathToHeader }}"
{% end -%}

{%- if isNamespace -%}
namespace {{ namespace | namespaceToStr }} {
{% end -%}

{{ makeTrivialTypes(symbols) }}

{%- for data in nestedList -%}

{%- if data.type == "module" -%}
namespace impl {
{%- end %}

{%- if data.type in ["module", "interface"] -%}

{{ data.comment | normalComment -}}
class {{ data.name }}{%- if data.hasInheritance %} : {{ data.inheritanceList | inheritanceToStr -}}{%- end %}
{
public: // Types
	{{ makeTrivialTypes(data.nested.symbols) }}

public: // Methods.

	{% for method in data.nested.methodList -%}
	{{ method.comment | normalComment }}
	virtual {{ method.type | typeToStr }} {{ method.name }}({% for i, var in method.args %}{% if var.const %}const {% end %}{{var.type | typeToStr }} {{ var.name }}{% if var.isValue %} = {{ var.value }}{% end %}{% if i %},{% end %}{% end %}) = 0;
	{%- end %}

public: // Variable accessors.

	{% for var in data.nested.variableList -%}

	// Getter for {{ var.name }}_.
	constexpr const {{ var.type | typeToStr }}& get{{ var.name | camelCase }}() const noexcept
	{
		return {{ var.name }}_;
	}

	{% if not var.const -%}
	// Setter for {{ var.name }}_.
	constexpr void set{{ var.name | camelCase }}(const {{ var.type | typeToStr }}& value)
	{
		{{ makeContractAssertions(var.contracts) }}
		{{ var.name }}_ = value;
	}
	{% end %}
	{%- end %}

protected: // Protected variable accessors.

	{% for var in data.nested.variableList -%}

	{% if var.const %}
	// Setter for {{ var.name }}_.
	constexpr void set{{ var.name | camelCase }}(const {{ var.type | typeToStr }}& value)
	{
		{{ makeContractAssertions(var.contracts) }}
		{{ var.name }}_ = value;
	}
	{% end %}
	{%- end %}

private: // Variables.
	{% for var in data.nested.variableList %}
	{{ makeVariable(var, "_") }}
	{%- end %}
};

{%- end -%}

{%- if data.type == "module" %}
}
{%- end %}

{%- end %}

{%- if isNamespace %}
}
{%- end %}
