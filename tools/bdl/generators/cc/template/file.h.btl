{#- Re-usable macros -#}
{%- include "tools/bdl/generators/cc/template/declarations.h.btl" -%}

{#- Contract assertion -#}
{%- macro makeContractAssertions(contracts) %}
	{% for contract in contracts %}
		{% if contract.type == "min" %}
// Minimum contract
assert(value >= {{ contract.value }});
		{% elif contract.type == "max" %}
// Maximum contract
assert(value <= {{ contract.value }});
		{% end %}
	{% end %} 
{% end -%}

{#- Start of the actual template -#}

#pragma once

#include <cassert>

#include "tools/bdl/generators/cc/adapter/types.h"

// **** Dependencies ****
{% for use in useList %}
#include "{{ use.path | bdlPathToHeader }}"
{% end %}
// ****

{% if isNamespace %}
namespace {{ namespace | namespaceToStr }} {
{% end %}

{{- declareTrivialTypes(sequence) -}}

{% for data in nestedList %}
	{% if data.type in ["interface"] %}

// Specialization for trivial types
class {{ data.name }}{% if data.hasInheritance %} : {{ data.inheritanceList | inheritanceToStr }}{% end %}
{
public: // Types
	{{ declareTrivialTypes(data.nested.sequence) }}

{% if data.virtual %}
public: // Methods
	{% for method in data.nested.methodList %}
	{{ method.comment | commentBlockToStr }}{% if method.isType %}[[nodiscard]] {% end %}virtual {{ method.type | typeToStr }} {{ method.name }}({{ declareParameters(method.parameters, true) }}) = 0;
	{% end %}
{% end %}
};

namespace adapter {

template <class Impl>
{{ data.comment | commentBlockToStr }}class {{ data.name }} : public {{ data.fqnToType | typeToStr }}{% if data.hasInheritance %}, {{ data.inheritanceList | inheritanceAdapterToStr }}{% end %}
{
public: // Traits
	using Self = {{ data.name }}<Impl>;

public: // Internal
	[[nodiscard]] constexpr Self& base() noexcept { return *this; }

{% if not data.virtual %}
public: // Methods.
	{% for method in data.nested.methodList %}
	{{ method.comment | commentBlockToStr }}{% if method.isType %}[[nodiscard]] {% end %}constexpr {{ method.type | typeToStr }} {{ method.name }}({{ declareParameters(method.parameters, true) }})
	{
		{% if method.isType %}return {% end %}static_cast<Impl*>(this)->{{ method.name }}({{ declareParametersCall(method.parameters) }});
	}
	{% end %}
{% end %}

public: // Variable accessors.
	{% for var in data.nested.expressionList %}

	/**
	 * Getter for the variable '{{ var.name }}'.
	 * \return The value of '{{ var.name }}'.
	 */
	[[nodiscard]] constexpr const {{ var.type | typeReferenceToStr }} get{{ var.name | toCamelCase }}() const noexcept
	{
		return {{ var.name }}_;
	}

		{% if not var.const %}
	/**
	 * Setter for the variable '{{ var.name }}'.
	 * \param value The new value to be set.
	 */
	constexpr void set{{ var.name | toCamelCase }}(const {{ var.type | typeReferenceToStr }}& value)
	{
		{{ makeContractAssertions(var.contracts) }}
		{{ var.name }}_ = value;
	}
		{% end %}
	{% end %}

protected: // Protected variable accessors.

	{% for var in data.nested.expressionList %}
		{% if var.const %}
	/**
	 * Setter for the constant variable '{{ var.name }}'.
	 * \param value The new value to be set.
	 */
	constexpr void set{{ var.name | toCamelCase }}(const {{ var.type | typeReferenceToStr }}& value)
	{
		{{ makeContractAssertions(var.contracts) }}
		{{ var.name }}_ = value;
	}
		{% end %}
	{% end %}

private: // Variables.
	{% for var in data.nested.expressionList %}
	{{ declareExpression(var, "_", false) }};
	{% end %}
};

}

{%- end -%}

{%- end %}

{%- if isNamespace %}
}
{%- end %}
