{#- Reusable macros -#}
{#- Enum -#}
{%- macro makeEnum(element) %}
{{ element.comment | normalComment }}
enum class {{ element.name }} : bzd::UInt8Type
{
	{%- for i, value in element.values -%}
	{%- if i -%},{%- end -%}
	{{ value.comment | normalComment }}
	{{ value.name }}
	{%- end %}
};
{% end -%}

{#- Contract assertion -#}
{%- macro makeContractAssertions(sequence) -%}
{%- for contract in sequence -%}
{% if contract.type == "min" -%}
// Minimum contract
assert(value >= {{ contract.value }});
{% elif contract.type == "max" -%}
// Maximum contract
assert(value <= {{ contract.value }});
{% end -%}
{%- end -%} 
{%- end -%}

{#- Start of the actual template -#}

#pragma once

#include <cassert>

#include "tools/bdl/generators/cc/adapter/types.h"

{% for use in useList -%}
#include "{{ use.path | bdlPathToHeader }}"
{% end -%}

{%- if isNamespace -%}
namespace {{ namespace | namespaceToStr }} {
{% end -%}

{%- for data in usingList -%}
using {{ data.name }} = {{ data.type | typeToStr }};
{% end -%}

{%- for data in enumList -%}{{ makeEnum(data) }}{%- end -%}

{%- for data in nestedList -%}

{%- if data.type == "module" -%}
namespace impl {
{%- end %}

{{ data.comment | normalComment -}}
class {{ data.name }}{%- if data.hasInheritance %} : {{ data.inheritanceList | inheritanceToStr -}}{%- end %}
{
public: // Types
	{%- for nested in data.nested.enumList -%}{{ makeEnum(nested) }}{%- end -%}

public: // Methods.

	{% for method in data.nested.methodList -%}
	{{ method.comment | normalComment }}
	virtual {{ method.type | typeToStr }} {{ method.name }}({% for i, var in method.args %}{% if var.const %}const {% end %}{{var.type | typeToStr }} {{ var.name }}{% if var.isValue %} = {{ var.value }}{% end %}{% if i %},{% end %}{% end %}) = 0;
	{%- end %}

public: // Variable accessors.

	{% for var in data.nested.variableList -%}

	// Getter for {{ var.name }}_.
	constexpr const {{ var.type | typeToStr }}& get{{ var.name | camelCase }}() const noexcept
	{
		return {{ var.name }}_;
	}

	{% if not var.const -%}
	// Setter for {{ var.name }}_.
	constexpr void set{{ var.name | camelCase }}(const {{ var.type | typeToStr }}& value)
	{
		{{ makeContractAssertions(var.contracts) }}
		{{ var.name }}_ = value;
	}
	{% end %}
	{%- end %}

protected: // Protected variable accessors.

	{% for var in data.nested.variableList -%}

	{% if var.const %}
	// Setter for {{ var.name }}_.
	constexpr void set{{ var.name | camelCase }}(const {{ var.type | typeToStr }}& value)
	{
		{{ makeContractAssertions(var.contracts) }}
		{{ var.name }}_ = value;
	}
	{% end %}
	{%- end %}

private: // Variables.
	{% for var in data.nested.variableList %}
	{{ var.comment | normalComment }}
	{{ var.type | typeToStr }} {{ var.name }}_{ {% if var.isValue %}{{ var.value }}{% end %} };
	{%- end %}
};

{%- if data.type == "module" %}
}
{%- end %}

{%- end %}

{%- if isNamespace %}
}
{%- end %}
