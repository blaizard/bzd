{#- Re-usable macros -#}
{%- include "tools/bdl/generators/cc/template/declarations.h.btl" -%}

{#- Contract assertion -#}
{%- macro makeContractAssertions(contracts) %}
	{% for contract in contracts %}
		{% if contract.type == "min" %}
// Minimum contract
assert(value >= {{ contract.value }});
		{% elif contract.type == "max" %}
// Maximum contract
assert(value <= {{ contract.value }});
		{% end %}
	{% end %} 
{% end -%}

{#- Start of the actual template -#}

#pragma once

#include <cassert>

#include "tools/bdl/generators/cc/adapter/types.hh"

// **** Dependencies ****
{% for use in useList %}
#include "{{ use.path | bdlPathToHeader }}"
{% end %}
// ****

{% if isNamespace %}
namespace {{ namespace | namespaceToStr }} {
{% end %}

{{- declareTrivialTypes(sequence) -}}

{% for data in nestedList %}
	{% if data.type == "interface" %}

// ==== Interface { data.name }
template <class Impl>
{{ data.comment | commentBlockToStr }}class {{ data.name }}{% if data.hasInheritance %} : {{ data.inheritanceList | inheritanceToStr }}{% end %}
{
protected:
	// An interface cannot be constructed directly.
	constexpr {{ data.name }}() noexcept
	{
		using bzd::typeTraits::isSame;
	{% for method in data.interface.methodList %}
		static_assert(isSame<typename Traits::{{ method.name }}::Signature, typename TraitsImpl::{{ method.name }}::Signature> && TraitsImpl::{{ method.name }}::isNoexcept,
					  "Wrong signature for method '{{ method.name }}', expecting: {{ declareMethod(method) }} noexcept;");
	{% end %}
	}

public: // Types
	{{ declareTrivialTypes(data.interface.sequence) }}

public: // Methods

	{% for method in data.interface.methodList %}
	{{ method.comment | commentBlockToStr }}{% if method.isType %}[[nodiscard]] {% end %}{{ declareMethod(method) }} noexcept
	{
		return static_cast<Impl*>(this)->{{ method.name }}({{ declareParametersCall(method.parameters) }});
	}

	{% end %}

public: // Variable accessors.

	{% for var in data.interface.expressionList %}
	// Getter for the variable '{{ var.name }}'.
	{{ var.comment | commentBlockToStr -}}
	// \return The value of '{{ var.name }}'.
	[[nodiscard]] constexpr {{ var.type | typeReferenceToStr }} {{ var.name }}() const noexcept
	{
		return static_cast<Impl*>(this)->{{ var.name }};
	}

	{% end %}

private: // Traits.
	struct TraitsImpl
	{
	{% for method in data.interface.methodList %}
		using {{ method.name }} = bzd::typeTraits::Function<decltype(&Impl::{{ method.name }})>;
	{% end %}
	};
	struct Traits
	{
	{% for method in data.interface.methodList %}
		using {{ method.name }} = bzd::typeTraits::Function<decltype(&{{ data.name }}<Impl>::{{ method.name }})>;
	{% end %}
	};
};

{%- end -%}

{%- end %}

{%- if isNamespace %}
}
{%- end %}

namespace bzd
{
{% for data in nestedList %}
	{% if data.type == "interface" %}
template <>
struct Interface<"{{ data.fqn }}">
{
	template <class Impl>
	[[nodiscard]] static auto& cast(Impl& impl) noexcept
	{
		return static_cast<{{ namespace | namespaceToStr }}::{{ data.name }}<Impl>&>(impl);
	}
};
	{% end %}
{% end %}
}
