{#- Re-usable macros. -#}
{%- include "tools/bdl/generators/cc/template/declarations.h.btl" -%}

{#- Generate calls for all init members associated with an expression. -#}
{%- macro callInitMembers(expresssion) -%}
	{% for dep in entities.expressions[expresssion].value.deps %}
co_await !registry.{{ dep.fqn | fqnToNameStr }}_.init(registry);
	{% end %}
	{% for dep in entities.expressions[expresssion].value.init %}
co_await !{{ dep.symbol | symbolRegistryToStr }}();
	{% end %}
{% end -%}

{#- Generate calls for all shutdown members associated with an expression. -#}
{%- macro callShutdownMembers(expresssion) -%}
	{% for dep in entities.expressions[expresssion].value.shutdown %}
co_await !{{ dep.symbol | symbolRegistryToStr }}();
	{% end %}
	{% for dep in entities.expressions[expresssion].value.deps %}
co_await !registry.{{ dep.fqn | fqnToNameStr }}_.shutdown(registry);
	{% end %}
{% end -%}

#include "cc/bzd/core/logger.hh"
#include "cc/bzd/core/assert.hh"
#include "cc/bzd/core/io/buffer.hh"
#include "cc/bzd/platform/clock.hh"
#include "cc/bzd/platform/stream.hh"
#include "cc/bzd/platform/atomic.hh"
#include "cc/bzd/algorithm/copy_n.hh"
#include "cc/bzd/meta/string_literal.hh"
#include "cc/bzd/utility/synchronization/spin_mutex.hh"
#include "cc/bzd/utility/synchronization/sync_lock_guard.hh"
{% for path in includes %}
#include "{{ path }}"
{% end %}

// for deploy in deployments

namespace {

enum class Status
{
	uninitialized,
	initializing,
	initialized,
	shuttingDown,
};

template <bzd::meta::StringLiteral name>
class ResourceSpecialization;

/// Wrapper around a registry entry.
///
/// \tparam name The FQN of the resource.
/// \tparam T The data type of the resource.
/// \tparam Registry The registry type to be used with this resource.
template <bzd::meta::StringLiteral name, class T>
class Resource : public ResourceSpecialization<name>
{
public: // Constructor.
	Resource(T& obj) noexcept : obj_{obj} {}

public: // Init/Shutdown.
	bzd::Async<> init(auto& registry) noexcept
	{
		const auto scope = bzd::makeSyncLockGuard(mutex_);
		++refCount_;
		if (this->status_ == Status::uninitialized)
		{
			this->status_ = Status::initializing;
			co_await !ResourceSpecialization<name>::init(registry);
			this->status_ = Status::initialized;
		}
		co_return {};
	}
	bzd::Async<> shutdown(auto& registry) noexcept
	{
		const auto scope = bzd::makeSyncLockGuard(mutex_);
		if (refCount_ == 1u)
		{
			this->status_ = Status::shuttingDown;
			co_await !ResourceSpecialization<name>::shutdown(registry);
			this->status_ = Status::uninitialized;
		}
		--refCount_;
		bzd::assert::isTrue(refCount_ >= 0, "Reference counter went < 0: {}"_csv, refCount_);
		co_return {};
	}

public: // Accessors.
	[[nodiscard]] auto& get() noexcept { return obj_; }
	[[nodiscard]] const auto& get() const noexcept { return obj_; }

protected:
	T& obj_;
	Status status_{Status::uninitialized};
	bzd::SpinMutex mutex_{};
	bzd::Int32 refCount_{0};
};

} // namespace

// ==== Platform ==============================================================

namespace bzd::platform::backend {
{% for fqn, expression in platform %}
static ::{{ expression.interfaceTypeResolved | symbolToStr }}* {{ expression.name }}{nullptr};
{% end %}
} // bzd::platform::backend

namespace bzd::platform {

{% for fqn, expression in platform %}
[[nodiscard]] ::{{ expression.interfaceTypeResolved | symbolToStr }}& {{ expression.name }}() noexcept
{
	return *::bzd::platform::backend::{{ expression.name }};
}
{% end %}

} // bzd::platform

// ==== Specializations =======================================================

namespace {

{% for fqn, expression in registry %}

// Specialization for '{{ fqn | fqnToStr }}'.
template <>
class ResourceSpecialization<"{{ fqn }}">
{
public:
	{{ paramsTemplateDefinition(expression.parametersResolved) }}
	struct Config
	{
		{{ paramsConstructorDefinition("Config", expression.parametersResolved) }}
	{% for index, item in expression.parametersResolved %}
		{{ item.comment | commentBlockToStr }}
		{{- paramToDefinition(item, index) }}
	{% end %}
	};

	{{ iterableTemplateDefinition(registryConnections[fqn].keys()) }}
	struct IO
	{
		{{ iterableConstructorDefinitionRValue("IO", registryConnections[fqn].keys()) }}
	{% for index, name in registryConnections[fqn].keys() %}
		T{{ index }} {{ name }};
	{% end %}
	};

protected:
	bzd::Async<> init([[maybe_unused]] auto& registry) noexcept
	{
		{{ callInitMembers(expression) }}
		{% if fqn in platform %}
		::bzd::platform::backend::{{ expression.name }} = &registry.{{ fqn | fqnToNameStr }}_.get();
		{% end %}
		co_return {};
	}
	bzd::Async<> shutdown([[maybe_unused]] auto& registry) noexcept
	{
		{% if fqn in platform  %}
		::bzd::platform::backend::{{ expression.name }} = nullptr;
		{% end %}
		{{ callShutdownMembers(expression) }}
		co_return {};
	}
};
{% end %}

// ==== Registry ==============================================================

{% for executorFQN in executors %}

[[nodiscard]] auto& makeRegistry{{ executorFQN | fqnToCapitalized }}() noexcept
{
	// Definition of communication ring buffers.
	{% for connection in connections[executorFQN] %}
	bzd::io::Buffer<{{ connection.symbol | symbolToStr }}, {{ connection | connectionCount }}u> io_buffer_{{ connection.input | symbolToNameStr }};
	{% end %}

	// Definition of all registry entries and their configuration.
	{% for fqn, expression in registryByExecutor[executorFQN] %}
	static const ResourceSpecialization<"{{ fqn }}">::Config config_{{ fqn | fqnToNameStr }}{ {{- paramsDeclaration(expression.parametersResolved | paramsFilterOutLiterals) -}} };
	[[maybe_unused]] static const ResourceSpecialization<"{{ fqn }}">::IO io_{{ fqn | fqnToNameStr }}{ {{- registryConnectionsDeclaration(registryConnections[fqn]) -}} };
	static {{ expression.typeResolved | symbolDefinitionToStr }} {{ fqn | fqnToNameStr }}{config_{{ fqn | fqnToNameStr }}};
	{% end %}

	// Declaration of the registry.
	struct Registry
	{
		{% for fqn, expression in registryByExecutor[executorFQN] %}
		Resource<"{{ fqn }}", decltype({{ fqn | fqnToNameStr }})> {{ fqn | fqnToNameStr }}_;
		{% end %}
	};
	static Registry registry{ {%- for fqn, expression in registryByExecutor[executorFQN] %}{% if not loop.first %}, {% end %}{{ fqn | fqnToNameStr }}{% end -%} };
	return registry;
}

{% end %}

/// Helper to handle return code.
template <class Promise>
[[nodiscard]] constexpr bzd::Bool verifyReturnedPromise(Promise&& promise, const bzd::StringView taskName) noexcept
{
	if (!promise.hasResult())
	{
		bzd::log::error("Task '{}' did not terminate correctly."_csv, taskName).sync();
		return false;
	}
	
	const auto result{promise.moveResultOut()};
	if (result.hasError())
	{
		bzd::log::error("Task '{}' terminated with an error."_csv, taskName).sync();
		bzd::log::error(result.error()).sync();
		return false;
	}

	return true;
}

bzd::Async<> initPlatform([[maybe_unused]] auto& registry) noexcept
{
	{% for fqn, expression in platform %}
	co_await !registry.{{ fqn | fqnToNameStr }}_.init(registry);
	{% end %}
	co_await !bzd::log::info("Initialization of platform completed."_csv);
	co_return {};
}

} // namespace

// ==== Identifiers ===========================================================

namespace bzd {

template <meta::StringLiteral name>
struct Data
{
	static UInt32 id;
};

{% for fqn, uid in uids %}
template <> UInt32 Data<"{{ fqn }}">::id = {{ uid }}u;
{% end %}

} // namespace bzd

// ==== Execution =============================================================

{% for executorFQN in executors %}

/// Initialize and compose the application.
bool run{{ executorFQN | fqnToCapitalized }}() noexcept
{
	// Create registry.
	[[maybe_unused]] auto& registry = makeRegistry{{ executorFQN | fqnToCapitalized }}();

	// Initialize platform.
	bzd::ignore = initPlatform(registry).sync();

	// Initialize executors.
	registry.{{ executorFQN | fqnToNameStr }}_.init(registry).sync();
	bzd::log::info("[{{ executorFQN }}] Initialization completed."_csv).sync();

	// Composition.
	bzd::log::info("[{{ executorFQN }}] Composition phase."_csv).sync();
	{% for expression, asyncType in asyncs.get(executorFQN) %}

	// {{ asyncType.value }}: {{ expression.symbol | symbolToStr }}()
	auto async_{{loop.parent.index}}_{{ loop.index }} = [&]() -> bzd::Async<> {
		{{ callInitMembers(expression) }}
		co_await !{{ expression.symbol | symbolRegistryToStr }}( {{- paramsDeclaration(expression.parametersResolved, true) -}} );
		{{ callShutdownMembers(expression) }}
		co_return {};
	};
	auto promise_{{loop.parent.index}}_{{ loop.index }} = async_{{loop.parent.index}}_{{ loop.index }}();
	registry.{{ executorFQN | fqnToNameStr }}_.get().schedule(promise_{{loop.parent.index}}_{{ loop.index }}, {{ asyncType | asyncTypeToStr }});
	{% end %}

	// Execute.
	bzd::log::info("[{{ executorFQN }}] Execution phase."_csv).sync();
	registry.{{ executorFQN | fqnToNameStr }}_.get().start();

	// Wait until completion.
	registry.{{ executorFQN | fqnToNameStr }}_.get().stop();
	bzd::log::info("[{{ executorFQN }}] Completion."_csv).sync();

	// Compute the return code.
	bool isSuccess{true};
	{% for expression, asyncType in asyncs.get(executorFQN) %}
		{% if asyncType == AsyncType.workload %}
	isSuccess &= verifyReturnedPromise(bzd::move(promise_{{loop.parent.index}}_{{ loop.index }}), "{{ expression.symbol | symbolToStr }}()"_sv);
		{% end %}
	{% end %}
	return isSuccess;
}

{% end %}
