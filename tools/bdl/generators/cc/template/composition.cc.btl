{#- Re-usable macros -#}
{%- include "tools/bdl/generators/cc/template/declarations.h.btl" -%}

#include "cc/bzd/core/logger.hh"
#include "cc/bzd/platform/clock.hh"
#include "cc/bzd/platform/stream.hh"
#include "cc/bzd/algorithm/copy_n.hh"
{% for path in includes %}
#include "{{ path }}"
{% end %}

// Backend platform symbols
namespace bzd::platform::backend {

bzd::OStream* out{nullptr};
bzd::IStream* in{nullptr};
bzd::Clock* steadyClock{nullptr};
bzd::Clock* systemClock{nullptr};

} // namespace bzd::platform::backend

// for deploy in deployments

namespace {

template <bzd::SizeType n>
struct StringLiteral
{
    constexpr StringLiteral(const char (&str)[n])
	{
        bzd::algorithm::copyN(str, n, value_);
    }

    char value_[n];
};

/// Wrapper around a registry entry.
template <StringLiteral name, class T, class Registry>
class BaseWrapper
{
public: // Constructor.
	BaseWrapper(T& obj, Registry& registry_) noexcept : obj_{obj}, registry{registry_} {}

public: // Accessors.
	[[nodiscard]] auto& get() noexcept { return obj_; }
	[[nodiscard]] const auto& get() const noexcept { return obj_; }

protected:
	T& obj_;
	Registry& registry;
};

template <StringLiteral name, class T, class Registry>
class Wrapper;

// ==== Specializations =======================================================
{% for expresssion in registry %}
// Specialization for {{ expresssion.fqn | fqnToStr }}
template <class T, class Registry>
class Wrapper<"{{ expresssion.fqn }}", T, Registry> : public BaseWrapper<"{{ expresssion.fqn }}", T, Registry>
{
public:
	using BaseWrapper<"{{ expresssion.fqn }}", T, Registry>::BaseWrapper;
	using BaseWrapper<"{{ expresssion.fqn }}", T, Registry>::registry;

	bzd::Async<> init() noexcept
	{
		{% for dep in dependencies.map[expresssion].preDeps %}
		co_await registry.{{ dep.fqn | fqnToNameStr }}_.init().template assert<0>();
		{% end %}
		{% for dep in dependencies.map[expresssion].pre %}
		co_await {{ dep.type | typeRegistryToStr }}().template assert<0>();
		{% end %}
		{% if expresssion.fqn == "out" %}
		bzd::platform::backend::out = &registry.{{ expresssion.fqn | fqnToNameStr }}_.get();
		co_await bzd::log::info("Stdout ready."_csv).template assert<0>();
		{% elif expresssion.fqn == "in" %}
		bzd::platform::backend::in = &registry.{{ expresssion.fqn | fqnToNameStr }}_.get();
		{% elif expresssion.fqn == "steadyClock" %}
		bzd::platform::backend::steadyClock = &registry.{{ expresssion.fqn | fqnToNameStr }}_.get();
		{% elif expresssion.fqn == "systemClock" %}
		bzd::platform::backend::systemClock = &registry.{{ expresssion.fqn | fqnToNameStr }}_.get();
		{% end %}
		co_return {};
	}
	bzd::Async<> shutdown() noexcept
	{
		{% if expresssion.fqn == "out" %}
		bzd::platform::backend::out = nullptr;
		{% elif expresssion.fqn == "in" %}
		bzd::platform::backend::in = nullptr;
		{% elif expresssion.fqn == "steadyClock" %}
		bzd::platform::backend::steadyClock = nullptr;
		{% elif expresssion.fqn == "systemClock" %}
		bzd::platform::backend::systemClock = nullptr;
		{% end %}
		co_return {};
	}
};
{% end %}


// ==== Registry ==============================================================
[[nodiscard]] auto makeRegistry() noexcept
{
	// Definition of all registry entries.
	{% for expresssion in registry %}
	static {{ expresssion.typeResolved | typeDefinitionToStr }} {{ expresssion.fqn | fqnToNameStr }}{ {{- declareParametersResolvedValues(expresssion.parametersResolved, false) -}} };
	{% end %}

	// Declaration of the registry.
	struct Registry
	{
		Registry({% for i, expresssion in registry %}{% if i %}, {% end %}decltype({{ expresssion.fqn | fqnToNameStr }})& {{ expresssion.fqn | fqnToNameStr }}{% end %})
			: {% for i, expresssion in registry %}{% if i %}, {% end %}{{ expresssion.fqn | fqnToNameStr }}_{ {{ expresssion.fqn | fqnToNameStr }}, *this }{% end %} {}
		{% for expresssion in registry %}
		Wrapper<"{{ expresssion.fqn }}", decltype({{ expresssion.fqn | fqnToNameStr }}), Registry> {{ expresssion.fqn | fqnToNameStr }}_;
		{% end %}
	};
	return Registry{ {%- for i, expresssion in registry %}{% if i %}, {% end %}{{ expresssion.fqn | fqnToNameStr }}{% end -%} };
}

/// Helper to handle return code.
template <class Promise>
[[nodiscard]] constexpr bzd::BoolType verifyReturnedPromise(Promise&& promise, const bzd::StringView taskName) noexcept
{
	if (!promise.isReady())
	{
		bzd::log::error("Task '{}' did not terminate correctly."_csv, taskName).sync();
		return false;
	}
	
	const auto result{promise.moveResultOut()};
	if (result->hasError())
	{
		bzd::log::error("Task '{}' terminated with an error."_csv, taskName).sync();
		bzd::log::error(result->error()).sync();
		return false;
	}

	return true;
}

} // namespace

/// Initialize and compose the application.
bool execute() noexcept
{
	// Create registry.
	[[maybe_unused]] auto registry = makeRegistry();

	// Initialize registry if needed and assign special symbols
	// to their platform backend if applicable.
	{% for item in initialization %}
		{% if item.isCall %}
	{{ item.call.type | typeRegistryToStr }}( {{- declareParametersResolvedValues(item.call.parametersResolved, true) -}} );
		{% end %}
		{% if item.fqn == "out" %}
	bzd::platform::backend::out = &registry.{{ item.fqn | fqnToNameStr }}_.get();
	bzd::log::info("Initialization phase."_csv).sync();
		{% elif item.fqn == "in" %}
	bzd::platform::backend::in = &registry.{{ item.fqn | fqnToNameStr }}_.get();
		{% elif item.fqn == "steadyClock" %}
	bzd::platform::backend::steadyClock = &registry.{{ item.fqn | fqnToNameStr }}_.get();
		{% elif item.fqn == "systemClock" %}
	bzd::platform::backend::systemClock = &registry.{{ item.fqn | fqnToNameStr }}_.get();
		{% end %}
	{% end %}

	// Compose.
	bzd::log::info("Composition phase."_csv).sync();
	{% for index, entry in composition %}
	auto promise{{ index }} = {{ entry.entity.type | typeRegistryToStr }}( {{- declareParametersResolvedValues(entry.entity.parametersResolved, true) -}} );
	registry.{{ entry.entity.executor | fqnToNameStr }}_.get().schedule(promise{{ index }}, {{ entry.asyncType | asyncTypeToStr }});
	{% end %}

	// Execute.
	bzd::log::info("Execution phase."_csv).sync();
	{% for executor in executors %}
	registry.{{ executor | fqnToNameStr }}_.get().start();
	{% end %}

	// Wait until completion.
	{% for executor in executors %}
	registry.{{ executor | fqnToNameStr }}_.get().stop();
	{% end %}

	bzd::log::info("Completion."_csv).sync();
	bool isSuccess{true};
	{% for index, entry in composition %}
	{% if entry.asyncType == "active" %}
	isSuccess &= verifyReturnedPromise(bzd::move(promise{{ index }}), "{{ entry.entity.type | typeRegistryToStr }}"_sv);
	{% end %}
	{% end %}

	return isSuccess;
}
