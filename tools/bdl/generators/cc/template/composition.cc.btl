{#- Re-usable macros. -#}
{%- include "tools/bdl/generators/cc/template/declarations.h.btl" -%}

{#- Generate calls for all init members associated with an expression. -#}
{%- macro callInitMembers(expresssion) -%}
	{% for dep in entites.map[expresssion].deps %}
co_await !registry.{{ dep.fqn | fqnToNameStr }}_.init(registry);
	{% end %}
	{% for dep in entites.map[expresssion].pre %}
co_await !{{ dep.type | typeRegistryToStr }}();
	{% end %}
{% end -%}

{#- Generate calls for all shutdown members associated with an expression. -#}
{%- macro callShutdownMembers(expresssion) -%}
	{% for dep in entites.map[expresssion].post %}
co_await !{{ dep.type | typeRegistryToStr }}();
	{% end %}
	{% for dep in entites.map[expresssion].deps %}
co_await !registry.{{ dep.fqn | fqnToNameStr }}_.shutdown(registry);
	{% end %}
{% end -%}

#include "cc/bzd/core/logger.hh"
#include "cc/bzd/core/assert.hh"
#include "cc/bzd/platform/clock.hh"
#include "cc/bzd/platform/stream.hh"
#include "cc/bzd/platform/atomic.hh"
#include "cc/bzd/algorithm/copy_n.hh"
#include "cc/bzd/meta/string_literal.hh"
#include "cc/bzd/utility/synchronization/spin_mutex.hh"
#include "cc/bzd/utility/synchronization/sync_lock_guard.hh"
{% for path in includes %}
#include "{{ path }}"
{% end %}

// for deploy in deployments

namespace {

enum class Status
{
	uninitialized,
	initializing,
	initialized,
	shuttingDown,
};

template <bzd::meta::StringLiteral name>
class ResourceSpecialization;

/// Wrapper around a registry entry.
///
/// \tparam name The FQN of the resource.
/// \tparam T The data type of the resource.
/// \tparam Registry The registry type to be used with this resource.
template <bzd::meta::StringLiteral name, class T>
class Resource : public ResourceSpecialization<name>
{
public: // Constructor.
	Resource(T& obj) noexcept : obj_{obj} {}

public: // Init/Shutdown.
	bzd::Async<> init(auto& registry) noexcept
	{
		const auto scope = bzd::makeSyncLockGuard(mutex_);
		++refCount_;
		if (this->status_ == Status::uninitialized)
		{
			this->status_ = Status::initializing;
			co_await !ResourceSpecialization<name>::init(registry);
			this->status_ = Status::initialized;
		}
		co_return {};
	}
	bzd::Async<> shutdown(auto& registry) noexcept
	{
		const auto scope = bzd::makeSyncLockGuard(mutex_);
		if (refCount_ == 1u)
		{
			this->status_ = Status::shuttingDown;
			co_await !ResourceSpecialization<name>::shutdown(registry);
			this->status_ = Status::uninitialized;
		}
		--refCount_;
		bzd::assert::isTrue(refCount_ >= 0, "Reference counter went < 0: {}"_csv, refCount_);
		co_return {};
	}

public: // Accessors.
	[[nodiscard]] auto& get() noexcept { return obj_; }
	[[nodiscard]] const auto& get() const noexcept { return obj_; }

protected:
	T& obj_;
	Status status_{Status::uninitialized};
	bzd::SpinMutex mutex_{};
	bzd::Int32 refCount_{0};
};

} // namespace

// ==== Platform ==============================================================

namespace bzd::platform::backend {
{% for fqn, expression in platform %}
static ::{{ expression.interfaceTypeResolved | typeToStr }}* {{ expression.name }}{nullptr};
{% end %}
} // bzd::platform::backend

namespace bzd::platform {

{% for fqn, expression in platform %}
[[nodiscard]] ::{{ expression.interfaceTypeResolved | typeToStr }}& {{ expression.name }}() noexcept
{
	return *::bzd::platform::backend::{{ expression.name }};
}
{% end %}

} // bzd::platform

// ==== Specializations =======================================================

namespace {

{% for fqn, expression in registry %}

// Specialization for '{{ fqn | fqnToStr }}'.
template <>
class ResourceSpecialization<"{{ fqn }}">
{
public:
	{{ paramsTemplateDefinition(expression.parametersResolved) }}
	struct Config
	{
		{{ paramsConstructorDefinition("Config", expression.parametersResolved) }}
	{% for index, item in expression.parametersResolved %}
		{{ item.comment | commentBlockToStr }}
		{{- paramToDefinition(item, index) }}
	{% end %}
	};

protected:
	bzd::Async<> init([[maybe_unused]] auto& registry) noexcept
	{
		{{ callInitMembers(expression) }}
		{% if fqn in platform %}
		::bzd::platform::backend::{{ expression.name }} = &registry.{{ fqn | fqnToNameStr }}_.get();
		{% end %}
		co_return {};
	}
	bzd::Async<> shutdown([[maybe_unused]] auto& registry) noexcept
	{
		{% if fqn in platform  %}
		::bzd::platform::backend::{{ expression.name }} = nullptr;
		{% end %}
		{{ callShutdownMembers(expression) }}
		co_return {};
	}
};
{% end %}

// ==== Registry ==============================================================

[[nodiscard]] auto makeRegistry() noexcept
{
	// Definition of all registry entries and their configuration.
	{% for fqn, expresssion in registry %}
	static const ResourceSpecialization<"{{ fqn }}">::Config config_{{ fqn | fqnToNameStr }}{ {{- paramsDeclaration(expresssion.parametersResolved | paramsFilterOutLiterals) -}} };
	static {{ expresssion.typeResolved | typeDefinitionToStr }} {{ fqn | fqnToNameStr }}{config_{{ fqn | fqnToNameStr }}};
	{% end %}

	// Declaration of the registry.
	struct Registry
	{
		{% for fqn, expresssion in registry %}
		Resource<"{{ fqn }}", decltype({{ fqn | fqnToNameStr }})> {{ fqn | fqnToNameStr }}_;
		{% end %}
	};
	return Registry{ {%- for fqn, expresssion in registry %}{% if not loop.first %}, {% end %}{{ fqn | fqnToNameStr }}{% end -%} };
}

/// Helper to handle return code.
template <class Promise>
[[nodiscard]] constexpr bzd::Bool verifyReturnedPromise(Promise&& promise, const bzd::StringView taskName) noexcept
{
	if (!promise.hasResult())
	{
		bzd::log::error("Task '{}' did not terminate correctly."_csv, taskName).sync();
		return false;
	}
	
	const auto result{promise.moveResultOut()};
	if (result.hasError())
	{
		bzd::log::error("Task '{}' terminated with an error."_csv, taskName).sync();
		bzd::log::error(result.error()).sync();
		return false;
	}

	return true;
}

} // namespace

// ==== Identifiers ===========================================================

namespace bzd {

template <meta::StringLiteral name>
struct Data
{
	static UInt32 id;
};

{% for fqn, uid in uids %}
template <> UInt32 Data<"{{ fqn }}">::id = {{ uid }}u;
{% end %}

} // namespace bzd

// ==== Execution =============================================================

/// Initialize and compose the application.
bool execute() noexcept
{
	// Create registry.
	[[maybe_unused]] auto registry = makeRegistry();

	// Initialize platform.
	{% for fqn, expression in platform %}
	registry.{{ fqn | fqnToNameStr }}_.init(registry).sync();
	{% end %}
	bzd::log::info("Initialization of platform completed."_csv).sync();

	// Initialize executors.
	{% for fqn, executor in executors %}
	registry.{{ fqn | fqnToNameStr }}_.init(registry).sync();
	bzd::log::info("Initialization of '{{ fqn }}' completed."_csv).sync();
	{% end %}

	// Composition.
	{% for fqn, executor in executors %}
	bzd::log::info("Composition for '{{ fqn }}'."_csv).sync();
		{% for expression, asyncType in composition[fqn] %}

	// {{ asyncType.value }}: {{ expression.type | typeToStr }}()
	auto async_{{loop.parent.index}}_{{ loop.index }} = [&]() -> bzd::Async<> {
		{{ callInitMembers(expression) }}
		co_await !{{ expression.type | typeRegistryToStr }}( {{- paramsDeclaration(expression.parametersResolved, true) -}} );
		{{ callShutdownMembers(expression) }}
		co_return {};
	};
	auto promise_{{loop.parent.index}}_{{ loop.index }} = async_{{loop.parent.index}}_{{ loop.index }}();
	registry.{{ fqn | fqnToNameStr }}_.get().schedule(promise_{{loop.parent.index}}_{{ loop.index }}, {{ asyncType | asyncTypeToStr }});
		{% end %}
	{% end %}

	// Execute.
	bzd::log::info("Execution phase."_csv).sync();
	{% for executor in executors %}
	registry.{{ executor | fqnToNameStr }}_.get().start();
	{% end %}

	// Wait until completion.
	{% for executor in executors %}
	registry.{{ executor | fqnToNameStr }}_.get().stop();
	{% end %}
	bzd::log::info("Completion."_csv).sync();

	// Compute the return code.
	bool isSuccess{true};
	{% for fqn, executor in executors %}
		{% for expression, asyncType in composition[fqn] %}
			{% if asyncType == AsyncType.workload %}
	isSuccess &= verifyReturnedPromise(bzd::move(promise_{{loop.parent.index}}_{{ loop.index }}), "{{ expression.type | typeToStr }}()"_sv);
			{% end %}
		{% end %}
	{% end %}
	return isSuccess;
}
