# Channels

Channels are ways to communicate to the external world.
It can be used as a communication mean through local buses (I2C, UART...), shared memory or more widely via internet.

A channel consists of 2 layers, the adapter and the transport layer.
The adapter layer has the role to serialize/deserialize the data as well as consistency/errors checks at the data level.
The tranport layer has the role to transport data blobs via a bus, in addition to a blob, on specific buses it needs inputs
such as destination address, etc.

When configuring a channel, the transport can only be configured once (durign initialization), while the adapter
is responsible to "adapt" the Data payload to the transport. The adapter is initialized with arguments
that can be used with the transport interface, for the example a chip select, or I2C device address.

A channel (adapter + transport), exposes a common interface through a Data payload (adapter) and a common way to
monitor and control the transport component (transport).
Note, at compile time a channel is fully defined, makind this composition between the 2 layers a constant expression
exposing a Channel<Data> interface.

Some buses might have a Channel interface as well, buses like UART for example, which do not need adapters in betweeen and
can be used directly as is.
Also a channel can be made on top of another channel, by making one part of the transport interface, this allow nestiing channels
for complex schemes.

## Declaration

```
composition {
	// Register an I2C bus driver. This has an unique instance withinI2CTransport the application.
	// This is to ensure unique access if needed and avoid code duplication.
	// A communication driver must have a transport interface.
	i2c = I2C(role = "master", speed = 1000000);
}

interface I2CTransport
{
	read(...)
	write(...);
};

using I2CDevice = Adapter<Buffer, I2CTransport>;

composition {
	tempSensor = I2CDevice(address = 12, addressing = 10/*bit*/, transport = &i2c);
}
```

The representation of the Channel class in C++ would look like this:

```C++
using I2CDevice = Adapter<Data, I2CTransport>;

I2CDevice<10/*receive*/, 10/*send*/> i2CTempSensor(12, 10/*bit*/, &i2c);

template <class Data>
class I2CTempSensor : public Adapter<Data, I2CTransport>
{
public:
	constexpr I2CTempSensor(int address, int addressing)
			: Adapter<Data, I2CTransport>{address, addressing}
	{
	}

private:
	buffer<RecvBufferSize> receive_;
	buffer<SendBufferSize> send_;
};

template <class Data, class Transport>
class Adapter : public Channel<Data>
{
public:

	Adapter(Transport& transport) : transport_{transport} {}

	Result write(Data data) override
	{
		transport_.write(data);
	}

private:
	Transport& transport_;
};

// Specialization for I2C
...
	Adapter(int address, int mode, Transport& transport) : address_{address}, mode_{mode}, transport_{transport} {}

	Result write(Data data) override
	{
		transport_.write(address, data);
	}
...
```

## Adapter

The adapter implementation would be defined as follow:

```
interface I2CDevice {
	struct Data {
		integer data;
	}

	method serialize(Data) -> Result<Sequence<Byte>>;
	method deserialize(Sequence<Byte>) -> Result<Data>;
}
```

or a more complex adpater could be defined as follow:

```
interface I2CDevice {
	struct Data {
		integer destinationId;
		Sequence<Byte, 4> payload;
		integer crc [min = 0, max = 255];
		timestamp time;
	}

	method serialize(Data) -> Result<Sequence<Byte>>;
	method deserialize(Sequence<Byte>) -> Result<Data>;
}
```

By default serialize and deserialize templated functions will be autogenerated,
however the user can specialize their implementation if needed.
Here is an example of could look such function:

```c++
// Auto-generate serialization function
template <typename T>
Result<Sequence<Byte>> serialize(const T& data) const
{
	return bzd::Serialize<T>(data);
}

// Specialized function adds a byte in from of the payload
template <>
Result<Sequence<Byte>> serialize<uint8_t>(const uint8_t& data) const
{
	return Sequence<Byte>{0x2a, data};
}
```

## Transport

The transport implementation should have an interface as follow, the service related information
should remain the same, while the read/write method can have a specialized interface.

```
interface Transport {

	// Service related
	method start() -> Result<void>;
	method stop() -> Result<void>;
	method getStatus() -> Status;

	// Statistics
	sent = UInt32;
	received = UInt32;

	// Data
	onRead() -> // Optional
	method read() -> Result<Sequence<Byte>>;
	method write(Sequence<Byte>) -> Result<void>;
}
```

## Channel Interface

The user will only have access to the channel via its interface, which abstract all the transportation details underneath.
This interface is auto generated from the channel object.

```
interface Channel {
	struct Data {
		integer temperature;
		timestamp time;
	}

	read() ->
}
```

# Buffers

An optional message queue should be available in the transport layer for bus-wide messages, but also in the adapter layer for messages
that should be kept per instance, for example, for a specific SPI channel or a specific CAN message.

## Use Cases

### I2C device address or chip select interface

Some protocol need to set a signal or append some id to the payload in order to select the destination device. This is done in the adapter layer.

### Transport with exclusive access

Some transport layer might have access limited to a single transaction at a time.
This can be handled in the transport layer, with a mutex mechanism to prevent mutual access.

# Interrupt driven drivers

interrupt driven driver will write their payload into a receive queue, this can be handled
in the transport layer.
However, the adaptor might also want to keep some messages in a queue as well, for example
for some critical messages that should not be missed.

# Runtime discoverable adapter config

Some devices might require for example a discovery stage before assigning their addresses
from the adaptor.
!!! not supported yet
